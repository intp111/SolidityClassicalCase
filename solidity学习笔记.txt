合约的七大组成部分
  状态变量
  函数
  函数修饰器
  事件
  Error
  枚举
  结构体
  
  
silidity有三种数据位置
	storage:数据存储在链上，永久记录   存放在storage的变量又被称为状态变量
	memory：数据存储在内存，函数退出后就消失了
	calldata:数据会被存在一个专门存放函数参数的地方
	
	变量的声明和定义
		声明是指指名变量的类型和名字
		定义是指不仅知名变量的类型和名字，同时为变量分配存储空间并赋初值
		
solidity数据类型
	根据传参类型分为值类型和引用类型
	
	值类型：保存的是变量的数据内容
		布尔类型 整型  静态浮点型  地址类型  静态字节数组  枚举类型 自定义值类型 字面值
	引用类型 保存的是变量的地址，在赋值或传参时传递的是数据的地址
		数组  结构体  映射
		
	引用传递
		传递的是变量的地址，值类型一定是值传递，但引用类型不一定是引用传递，取决于
		变量位置
		
Solidity数据位置
	Solidity要求在声明引用类型的时候必须加上数据位置（data location）通常是在函数体里面的声明,
	但是在声明状态变量时不需要加上数据位置
		数据位置：storage memory calldata
		calldata的数据是不可更改的，相比于memory消耗更少的Gas
		
		引用类型：数组  映射  结构体
		
		calldata和memory的区别：
			不可更改
			易失的
			只能在引用类型的函数参数使用
			消耗更少的Gas
	原则：如果你的引用类型函数参数不需要修改，你应该尽可能使用calldata而不是memory
	
Solidity布尔类型
	bool   true false  默认初始值是false
	逻辑运算：  !  &&  ||  ==  !=
	
	短路原则：在满足左边条件时不会再执行右边的操作
		对f(x)||g(y),如果f(x)为true,则g(y)不会被执行
		对f(x)&&g(y),如果f(x)为false,则g(y)不会被执行

Solidity整型
	分为有符号整型和无符号整型两种
	无符号整型：uint8 uint16 uint24 ...uint256   8的倍数
	有符号整型：int8 int16 int24 ... int256   同样也是8的倍数
	int8和uint8占1个字节  其他以此类推
	
	运算符：
		算数运算符：+ - * / % **（幂运算） <<（左移）  >>（右移）
		比较运算
		位运算
		
Solidity地址类型
	地址类型是solidity独有的一种类型，它被用来存放账户地址  用于转账和与其他合约交互
	address 占20个字节 默认值是0x0 表示空地址
	地址类型可细分为两种：
		address:普通地址类型（不可接收转账）
		address payable:可收款地址类型（可接收转账）
		使用payble()函数将地址字面值显式转换为address payable类型
	
	为什么要区分address和address payable?
	
	成员变量
		balance code hashcode
		
	成员函数
		transfer() 向其他账户转账  转账失败不报异常，直接revert,Gas费用固定为2300wei，只能被address payable类型使用
		send() ： 与transfer() 类似  转账失败后返回false, Gas费用固定为2300wei，只能被address payable类型使用
		call():调用其他合约中的函数，费用不固定，指定，
		delegatecall() ：与call()函数类似，改变合约状态
		staticcall():与call()函数类似，不改变合约状态
		
Solidity静态字节数组
	一共有32中静态字节数组 bytes1 bytes2 bytes3 ... bytes32
	静态字节数组属于值类型！！！
	
	运算符：
		比较运算符 > < == != >= <=
		位运算：
	
	下标访问
		bytes3 b = 'abc';
		bytes1 ch = b[1];
		
	静态字节数组是固定长度的字节数组，是值类型，变量存储的是值而不是数据的地址
	
Solidity字面值
	字面值是指在程序中无需变量保存，可直接表示为一个具体的数字或字符串的值，包括：
		地址字面值
		有理数和整数字面值
		字符串字面值
		Unicode字面值
		
	地址字面值：长度为42字节的16进制字符串
		
	有理数和整数字面值
	Unicode字面值：与字符串字面值类似，只需要在前面加上unicode关键字即可
	字符串字面值：用单引号或双引号定义
		字符串字面值可以隐式类型转换成bytes1,bytes2,bytes3,...bytes32还有string类型
	
	只要字面值和非字面值进行了运算，那么字面值就会被尝试转换成非字面值的类型
	
Solidity枚举类型
	为什么要使用枚举类型？
		提高代码的类型安全性和可读性
		安全性：会在编译期进行检查
	通过.操作符访问枚举类型中的某一个枚举值
	
	最大值和最小值
	type(枚举类型).max
	type(枚举类型).min

	枚举类型和整型的相互转换
		强制类型转换
		
	枚举类型作为函数参数或返回值
		如果枚举类型仅在当前合约定义，那么外部合约在调用当前合约的时候它获取
		得到的枚举类型返回值应该是怎么样的？答案是枚举类型会被编译器自动转换成 
		uint8 类型。所以外部合约看到的枚举类型是 uint8 类型。
		这是因为 ABI 中没有枚举类型，只有整型，所以编译器会自动执行这样的转换。
		
		
Solidity自定义值类型
	定义：type C is V
		C是新定义的类型，V是Solidity原生类型
	
	缺少原类型的操作符（+ - * /等操作符）
	
	类型转换
		wrap()  和 unwrap()
		wrap()将原生类型转换为自定义类型
		unwrap()将自定义类型转换为原生类型

Solidity数组
	按照长度是否可以改变分为两种：静态数组  动态数组
	
	静态数组：
		定义：T[数组长度] DataLocation arrayName;   int[7] memory arr;
		!!!数组是引用类型，在定义的时候要注明数据位置（storage memory calldata）
		静态数组的大小必须在编译器确定，这意味着你不能使用变量来指定数组的大小
		初始化：
			零值初始化：如果只定义而不初始化，则会根据类型进行初始化
			使用数组字面值进行初始化，[1，2，3]
				注意使用时第一个元素要转换为数组的类型
				uint[3] memory arrName = [(uint)1,2,3],如果不加uint,编译时会报错
				同时注意长度一致
	动态数组：
		声明：T[] DataLocation arrName;
			uint[] memory arr;
		初始化：
			使用new关键字对动态数组进行初始化
			uint n = 3；
			uint[] storage arrName = new int[](n);
			
			当动态数组的数据位置是storage时，也可以使用数组字面值进行初始化
			uint[] arrName = [(uint)1,2,3];
				声明引用类型的变量时，必须注明数据位置，如果是状态变量则不用加storage
				状态变量是指数据位置是storage的变量
				
		使用下标访问数据元素

Solidity数组切片
	数组切片是基于数组建立的视图，其语法是arr[start:end] 代表从start到end-1的元素
	视图没有类型也不能占据存储空间
	
	数组切片的表示方法：
		arr[1:4] 代表从arr[1]到arr[3]的元素
		arr[:4]   省略start,代表从arr[0]开始到arr[3]
		arr[1:]		省略end,代表从arr[1]到arr[length1-1]
		arr[:]    全都省略，代表完整的数组
	
	数组切片只能作用于calldata
	
Solidity数组成员

	成员变量：  length
	成员函数
		只有数据位置是storage的动态数组，才有成员函数
			push()
			push(x)
			pop()
						数据位置是storage   动态数组

Solidity多维数组
	
	多维数组分为多维静态数组和多维动态数组
		多维静态数组
			声明：  uint[5][3] memory arr;  注意这代表3行5列的数组，而不是5行3列的数组
											从右往左！！！！
			初始化：
					零值初始化：如果只定义而不初始化，则会根据类型进行初始化
					使用数组字面值初始化，与一维静态数组类似，
					uint[3][2] memory arr = [[uint(1),2,3],[uint(4),5,6]]
		多维动态数组
			声明：uint[][] arrayName;
			初始化：
				使用new关键字对动态数组进行初始化，初始化的值为零值初始化
				对于数据位置为storage的动态数组，可以使用数组字面值初始化

Solidity动态字节数组
	动态字节数组是数组类型其中的一种类型，只不过是字节数组而已
	动态字节数组是引用类型，静态字节数组是值类型
	
	动态字节数组的种类
	bytes和string
	bytes类似于bytes1[],但不完全相同
	string类似于bytes,但不完全相同，string无法使用lenth获取长度，无法使用下标访问
	可以将stirng转换为bytes，获取长度和下标访问
	
	数据位置为memory/calldata的bytes string动态字节数组要比其他的数组更紧凑，
	其他类型的数组每一个元素要占据32字节的倍数，不足32字节自动padding到32字节，
	而bytes stir没有这样的要求
	
	bytes和string的相互转换
		string转bytes:
		string memory str = "hello world";
		bytes memory b = bytes(str);
	
		bytes转string
		bytes memory b = new bytes(10);
		string memory c = string(b);
		
Solidity结构体
	使用struct关键字
	结构体可以和数组、映射相互嵌套
	
	定义：
		struct Book{
			string title;
			uint price;
		}
	声明；
		Book momery book;
		
	初始化：
		Book memory book1 = Book(
		{
			title:"title",
			price:18
		}
		)
		或者
		Book memoy book2 = Book("title",18);
		
Solidity映射类型
	键值对
	mapping(keyType=>valueType) name;
	通过key存取对应value，使用[]操作符
	映射类型只能声明在storage中
	映射类型作为入参和返回值时，函数可见性必须是private或internal
	
	映射类型没有length属性
	无法进行遍历
	
控制结构
if-else
for 
while
do{}while()
break
continue

require
	异常处理
	Solidity异常处理的统一原则是状态回滚，目前solidity提供三个异常处理的函数
		require
		revert
		assert
	
	require函数的用途
		检查输入参数
		检查返回结果
		在实际执行函数逻辑前检查是否满足预设条件
	语法
		require(condition, "error string");  condition为bool类型
	一般情况下在函数的开始使用检查
	
	assert用于检查合约状态是否正常
	用途：
		检查不变性
		防止哪些不应该出现的情况出现
		修改合约状态后，检查合约内部状态是否符合预期
	一般情况下，在函数结尾使用assert检查合约状态
	
	语法：assert(condition);
	
	assert和require的区别
	一般情况下 require 是用来校验输入输出，与外部交互是否符合预期。而 assert 
	是用来校验内部是否出现不可接受的错误。一旦 assert 抛出异常，说明合约已经
	有了严重的 Bug ，需要马上处理
		
	revert
		类似于require，使用require不方便时，可以使用revert，revert可以和if-else配合使用


Solidity合约
	合约类似于类，合约中包含了成员属性和成员函数
	合约的组成结构：
		构造函数：初始化合约状态
		函数：逻辑代码块
		修饰器：修饰限定函数行为
		事件：用来记录函数执行事件，类似于log
		结构体：
		枚举：
		自定义值类型
		fallback函数：特殊函数，调用合约中的函数不存在时，就会执行fallback函数
		error：定义了函数可能抛出的Error
		using：在当前合约调用其他合约或库中定义的函数
		receive函数：特殊函数，用来接收ether转账
		
Solidity constant
	constant用来定义常量，constant的值必须在编译期确定
	必须在定义时就初始化
	
Solidity immutable
	与constant类似，定义一个常量，
	只允许初始化（赋值）一次，并允许在构建函数中再做初始化
	
	immutable允许：
		在声明时初始化
		在构建函数初始化
	 immutable 与 constant 的最大区别就是，它允许在构建函数中才做初始化
	 
	 但是不能初始化两次
	 不能在函数中初始化

Solidity函数
	function 函数名 (参数列表) 函数可见性  状态可变性  returns (返回值列表){
		函数主体
	}
	
		函数可见性和状态可变性？？？
		函数可见性(visibility)：internal external private public
		状态可变性(state mutability):pure view payable
		
		参数列表  函数可见性  可变性 修饰器 返回值列表 都是可选的
		
		函数可见性（visibility）：
			其他合约对当前合约函数的可访问性
			public private external internal
		函数状态可变性（state mutability）
			pure view payable
			函数状态可变性是指函数内部是否可以修改合约状态
			
Solidity 构建函数
	主要作用是对合约状态进行初始化
	constructor(){
	
	}

Solidity 修饰器
	modifier   修饰器是一种特殊的函数 
	修饰器的作用
		可以用来修饰、改变函数的行为  修饰器可以在函数执行前进行预处理和验证操作
		提高代码复用
	修饰器的语法
		modifier modifierName{
			// modifier body 1
			_;
			// modifier body 2
		}
		_代表占位符，代表函数主体
		执行顺序为
			modifier body1 ->被修饰的函数主体 -> modifier body2
			
	可以添加多个修饰器，执行顺序从左往右

Solidity可见性
	保证合约的安全性，Solidity允许对变量和函数访问进行限制
	Solidity中的可见性是指其他合约对当前合约中变量和函数的可访问性
	public private internal external
	
	变量可以使用public  private internal
		public：变量可以在当前合约内部和外部访问
		private：变量只能在当前合约内部访问
		internal：变量只能在当前合约内部或者其子合约访问
		
	函数都可以使用  public private external internal
	private：函数只能在当前合约内部访问
	public：函数可以在当前合约外部和内部访问
	internal：函数只能在当前合约内部或其子合约访问
	external:函数只能在当前合约外部访问

	合约的分类
		主合约(合约内部)  子合约  第三方合约（合约外部）
		子合约继承主合约  
		contract Child is Parent{
		}
		
	可见性对合约访问的限制
		可见性为 public 的变量和函数可以被任何合约访问。也就是可以被
		主合约 子合约 第三方合约访问
		
		可见性为 external 的函数只能被第三方合约访问。
		注意变量是没有 external 修饰符的
		
		可见性为 internal 的变量和函数可以被主合约和子合约访问
	
		可见性为 private 的变量和函数只能被主合约访问

Solidity状态可变性
	是否可以修改合约状态
	pure view payable
	
	pure  既不能查询，也不能修改函数状态，只能使用函数参数进行简单计算并返回结果
	view   只能查询合约状态 不能更改合约状态  只读不写
	payable  允许函数接收转账   
	
	如何定义查询合约状态？
		读取状态变量
		访问address(this).balance或者<address>.balance
		访问block tx msg的成员
		调用未标记为pure的任何函数
		使用包含某些操作码的内联汇编
	
	如何定义修改合约状态？
		修改状态变量
		触发事件
		创建其他合约
		使用 selfdestruct 来销毁合约
		通过函数调用发送以太币
		调用未标记为 view 或 pure 的任何函数
		使用低级别调用，如 transfer, send, call, delegatecall 等
		使用包含某些操作码的内联汇编

Solidity view函数

Solidity pure函数
	纯函数  pure function
	
		
	
	
	
		
			
	
		
	
		
	
	
		
		
	
	